<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="漂泊在日帝"><title>ReactiveCocoa简介 | cookie的部落格</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-101641631-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactiveCocoa简介</h1><a id="logo" href="/.">cookie的部落格</a><p class="description">这个人不懒，但就是什么都没有留下</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReactiveCocoa简介</h1><div class="post-meta">May 20, 2017</div><div class="post-content"><p>Update:2017-06-11:<br>更新一些最近找到的比较好的资料<br><a href="http://rxmarbles.com/#combineLatest" target="_blank" rel="external">rx对于数据流的处理</a><br><a href="http://ibloodline.com/articles/2016/03/21/RAC-3.html" target="_blank" rel="external">ReactiveCocoa操作方法</a><br><a href="http://fengjian0106.github.io/2016/04/17/The-Power-Of-Composition-In-FRP-Part-1/" target="_blank" rel="external">用 ReactiveCocoa 事半功倍的写代码(OC版本)</a></p>
<p>RAC最早是基于Objective-C的，所以在网上搜索ReactiveCocoa相关资料的话大概率会检索到Objective-C时期的教程。并且ReactiveCocoa的Swift版本—ReactiveSwift相对之前版本RAC，他的API名称以及类的名称发生了很大的变化（比如原来的signal都会带RAC前缀），所以尽管基本概念没有大变化，但旧教程对于目前的新版本RAC来说帮助还是不大。</p>
<p>这篇文章翻译自另一位博主的博客，他举的例子很浅显易懂。这篇文章中作者只介绍了RAC的响应式部分，函数式部分的介绍可以参照他另一篇文章<a href="http://mfclarke.github.io/2016/05/29/introduction-to-reactive-cocoa-4-pt-2-smooth-operators/" target="_blank" rel="external">链接</a>。<strong>原文中用到的是RAC4，现在最新版本已经是RAC5了，同样API的名称也发生了些改变，文章中如果有与最新RAC中不同的地方我会另外注明出来。</strong></p>
<p><a href="http://mfclarke.github.io/2016/04/23/introduction-to-reactive-cocoa-4/" target="_blank" rel="external">原文链接:Introduction to Reactive Cocoa 4 (part 1)</a></p>
<h5 id="ReactiveCocoa4-简介"><a href="#ReactiveCocoa4-简介" class="headerlink" title="ReactiveCocoa4 简介"></a>ReactiveCocoa4 简介</h5><p>ReactiveCocoa4是目前最新的版本，相较于之前的版本，他的语法发生了很大的变化。目前网上关于RAC的最新内容都只着眼于RAC4之前版本的对比，并不是从头开始教你去如何使用RAC。如果同时你又是一个函数式编程的新手，那么RAC的学习曲线对你来说可能就会更抖一些。<strong>现在不要再去想什么是flatMaps吧，我写这篇文章正是为了那些想了解ReactiveCocoa4，但对当前RAC版本一头雾水的小白程序员（尽管他们中的一些人可能了解过了什么是函数式编程）。</strong>在开始之前，先从Github上clone一下RAC的分支，然后启动项中的Playground（官方的repo里面有自带），冲好一杯☕。如果你准备好了，就让我们开始吧。</p>
<h6 id="Signals-Events-Values-这些到底讲的是啥？"><a href="#Signals-Events-Values-这些到底讲的是啥？" class="headerlink" title="Signals, Events, Values 这些到底讲的是啥？"></a>Signals, Events, Values 这些到底讲的是啥？</h6><p>打个比方，如果你要把一个Int值传到某个地方，在ReactiveCocoa4的场景中，这个Int值就是一个RAC的value类型，而传递这个value需要利用Signal作为通路，Signal可以在任意时间传递任意值。所以可以把Signal想象为一个连续不断地数据流。对于观察value的对象来说，他们需要持续观察这个value的Signal。</p>
<p>让我们上手试一下，假设我们需要传递一个Int值，为此我们需要创建一个Signal和与之对应的Observer，接下来我们使用这个Observer类型的对像来传递Int值。一开始这样说可能比较难懂。简单来说，<strong>这里的Observer对象不是指具体某个正在观察Signal的对象，而是指代所有正在观察这个Signal的对象。</strong> 当你用这个Observer去传递某个值时，实际上这个值会传递到所有正在观察该Signal的对象去。</p>
<p>一开始理解起来比较难，下面用具体的例子来示范一下如何使用RAC。首先我们需要用到pipe()函数来建立一个Signal和Observer的配对，然后试着传递一些值。</p>
<p><img src="/images/RAC/example1.jpg" width="700"></p>
<p>看一下这里发生了什么，首先我们利用pipe()函数产生了一个Signal和Observer的配对。Signal被设置为用来传递Int类型的值，然后我们设置Signal的闭包，每当一个值通过Signal传递，这个闭包就会被调用（成功地将回调部分代码与观察这个Signal的对象解耦）。最后我们再利用前面的Observer对象向Signal传递一些值。</p>
<p>正如你在Playground的图里看到的，每当有新的Int被传递时，闭包就会被调用。同时调用闭包的顺序与我们传递Int值的顺序是一致的 🎉。<br>但这边的Next指代的是什么呢？事实上，value被Next事件包装，然后向下发送Signal。其实并没有很多种事件能够产生Signal。<br>于此同时Signal的神奇之处在于他可以被任意数量的闭包所观察，所以sendNext函数中的参数可以被很多个闭包接收并处理。<br><span style="color:red">注意：RAC5.0 中ObserveNext已经变更为ObserveValue</span></p>
<p><img src="/images/RAC/example2.jpg" width="700"></p>
<h5 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h5><p>上面提到当值类型被Next事件包装起来，然后向下发送Signal。除了Next事件，还有其他一些事件类型。<br>首先是Failed事件，Failed事件传递一个ErrorType类型的参数，并且会终止Signal活动。如果当我们遇到某种场景需要终止Signal继续活动，同时还要把异常事件的具体情况通知给所有观察者的时候。我们就可以利用sendFailed将错误信息发送给各个观察者。</p>
<p><img src="/images/RAC/example3.jpg" width="700"></p>
<p>最后一个值12并没有被送至各个观察者，原因就是前面说的，Failed事件已经被发送至这个信号，所以这个信号就不再继续活动了。</p>
<p>接下来是Completed事件，这个事件同样和Failed事件一样能够终止Singal活动。用这个事件可以表示Signal已经完成了所有任务并不再被需要了。当Completed事件发生后，就算再传递新的值给Signal，也不会再触发任何闭包的调用。</p>
<p><img src="/images/RAC/example4.jpg" width="700"></p>
<p>最后是Interrupted事件，这个事件和Completed事件很像，但这种类型的事件是自动发生的。还记得用Signal的observeXX函数可以给不同的事件添加闭包吗？每次我们调用完这些方法后我们都能够得到一个Disposable类型的对象，调用这个对象的dispose方法可以让我们移除这个事件对Signal的观察行为。当一个信号没有被任何事件所观察时，Interrupted事件就被调用了。比方说一棵树落在一个无人的森林中，会不会发出声音我们可不知道，因为那附近并没有人🌝。</p>
<p><img src="/images/RAC/example5.jpg" width="700"></p>
<p>这些看上去都很有趣，但是能将这些应用到日常的开发中去么？先看看现在已经知道了些什么</p>
<ul>
<li>一个可观察对象，观察者可以通过Signal观察value的变化</li>
<li>一个用来发送这些value的对象（Observer）</li>
<li>错误处理</li>
</ul>
<p>回想下你经历过多少次更新一个model然后刷新那些正在使用这个model的对象来显示最新的内容。这样既麻烦又复杂。如果有一种方式不必使用KVO就能让你不用将对象关联起来也能及时的监听那些对象value的变化，这样会不会很赞。</p>
<p><img src="/images/RAC/example6.jpg" width="700"></p>
<p>这样很简洁，将所有代码逻辑（观察的设置，以及value变化时候的处理）都集中到了一个地方。只需要简单地提供一个可以让UILabel观察的Signal就可以了。不再需要任何关联、无休止的观察、或者任何同步处理。但需要特定的样板模式（对每一个需要观察的value来说需要一个Observer和一个Signal）。想象一下如果我们有一大堆拥有不同变量的model。猜猜看会发生什么？这是一个非常典型的ReactiveCocoa的使用场景，已经有人帮我们想到了，现在有请</p>
<h5 id="Mutable-Properties"><a href="#Mutable-Properties" class="headerlink" title="Mutable Properties"></a>Mutable Properties</h5><p>MutableProperties将需要观察的值包装起来，不需要再像之前一样建立Signal和Observer，让我们实际看下使用MutableProperties重写后的代码。</p>
<p><img src="/images/RAC/example7.jpg" width="700"></p>
<p>恩，这超简洁对吧。通过MutableProperties封装一般的变量，每个变量拥有了一个对应的Signal，每当value发生变化时，就会通过Signal通知给观察者。但还没完，当value变化时，还是需要在ObserverNext事件执行更新。猜猜谁又为我们考虑到了这种场景？现在有请</p>
<h5 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h5><p>你可以只使用一个”&lt;~”运算符将右边的值与左边的值绑定起来，每当右边的值得到更新时，左边的值也会更新。</p>
<p><img src="/images/RAC/example8.jpg" width="700"></p>
<p>这边我们建立了一个UILabel的子类BindableLabel，提供一个已经和UILabek成员text绑定的变量textBinding，然后我们只需要用”&lt;~”将textBinding与其他变量绑定就可以了。</p>
<p>一旦有了BindablkLabel，代码就能变得十分简洁。保持label的text与username一致只需要一行代码就可以完成。更加声明化，简单化。实际上，如果把注意力只放在Model和View的建立，绑定，那代码就像下面那样</p>
<p><img src="/images/RAC/example9.jpg" width="700"></p>
<p>你可以将任何东西与一个Signal，Observer的配对包装起来，然后让其他对象观察，或者与一个MutableProperties绑定，然后将所有触发行为的逻辑都放到一个地方。这太强大了，然而不幸的是并不是所有的绑定都像String &lt;~ String一样简单，我们有时候需要适当处理这些value、等待一些其他Signal的value、忽略某些value、更改某些value的类型使他们能被不同的对象使用。。。。</p>
<p>如何解决这些就写在我的下一篇文章中了，我们pt2再见👋</p>
<p>SEO：RAC5.0教程 ReactiveCocoa简介 ReactiveSwift简介 </p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2017/06/10/重拾AutoLayout/" class="pre">AutoLayout笔记</a><a href="/2017/05/14/To-the-Moon/" class="next">To the Moon</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/硬件/" style="font-size: 15px;">硬件</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Swift-Objective-C/" style="font-size: 15px;">Swift, Objective-C</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/swift/" style="font-size: 15px;">swift</a> <a href="/tags/游戏/" style="font-size: 15px;">游戏</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/16/Swift和OC混编Tips-1/">Swift和OC混编Tips-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/Swift和OC混编那点事/">Swift和OC混编--记一次Xcode的提示和高亮失效  </a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/12/iOS关于复杂View的横屏竖屏UI的对应/">iOS关于复杂View的横屏竖屏UI的对应</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/10/重拾AutoLayout/">AutoLayout笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/20/RAC简介/">ReactiveCocoa简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/To-the-Moon/">To the Moon</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/上班后第一个黄金周/">上班后第一个黄金周</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/07/代码简洁之循环和逻辑简单化/">代码简洁之循环和逻辑简单化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/利用AFNetworking自动更新Token/">利用AFNetworking自动更新Token</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/27/Swift面向协议编程/">Swift面向协议编程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">cookie的部落格.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>